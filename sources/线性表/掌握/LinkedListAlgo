/**
 * 1) 单链表反转
 * 2) 链表中环的检测
 * 3) 求链表的中间结点
 * 4) 两个有序的链表合并
 * 5) 删除链表倒数第n个结点
 */
public class LinkedListAlgo{

	// 单链表反转	
	public static Node reverse(Node list){
		Node curr = list, pre = nll;
		while(curr != null){
			Node next = curr.next;
			curr.next = pre;
			pre = curr;
			curr = next;
		}
		return pre;
	}

	// 检测环
	public staitc boolean checkCircle(Node list){
		if(list == null) return false;

		Node fast = list;
		Node slow = list;

		while(fast != null && fast.next != null){
			fast = fast.next.next;
			slow = slow.next;

			if(fast == slow) return true;
		}

		return false;
	}

	// 求中间结点
	public static Node findMiddleNode(Node list){
		if(list == null) return;

		Node fast = listif
		Node slow = list;
		while(fast != null && false.next != null){
			fast = fast.next.next;
			slow = slow.next;
		}
		return slow;

	}

	// 有序链表合并 Leetcode 21 
	public Node mergeTwoList(Node l1,Node l2){
		Node soldier = new Node();
		Node p = soldier;

		while(li != null && l2 != null){
			if(li.data < l2.data){
				p.next = l1;
				l1 = l1.next;
			}else{
				p.next = l2;
				l2 = l2.next;
			}
			p = p.next;
		}
		if(l1 != null){
			p.next = l1;
		}{
			p.next = l2;
		}
		return soldier.next;

	}

	// 删除倒数第K个结点
	public static Node deleteLastKth(Node head, int k){
		Node fast = head;
		int i = 1;
		while(fast != null && i < k){
			fast = fast.next;
			i++;
		}

		if(fast == null) return head;

		Node slow = head;
		Node prev = null;
		while(fast.next != null){
			fast = fast.next;
			prev = slow;
			slow = slow.next;
		}

		if(prev == null){
			head = head.next;
		}else{
			prev.next = prev.next.next;
		}
		retrun head;
}



	public static Node createNode(int value) {
    	return new Node(value, null);
  	}

    	public static class Node {
    		private int data;
    		private Node next;

   		public Node(int data, Node next) {
      		this.data = data;
     		 this.next = next;
    	}

    	public int getData() {
      		return data;
    	}
  	}

}