堆：
1.堆事一个完全二叉树
2.堆中每一个节点的值都必须大于等于(或小于等于)其子树中每个节点的值。
大于：大顶堆 小于：小顶堆。



public class Heap{
	private int[] a; //数组，从下标1开始储存数据
	private int n; //堆可以储存的最大数据个数
	private int count; //堆中已经储存的数据个数

	public Heap(int capacity){
		a = new int[capacity + 1];
		n = capacity;
		count = 0;
	}

	public void insert(int data){
		if(count >= n) return; //堆满了
		++count;
		a[count] = data;
		int i = count;
		while(i/2 > 0; a[i] > a[i/2]){ //自下往上堆化
			swap(a,i,i/2);
			i = i/2;
		}

	}

	public void removeMax(){
		if(count == 0)return -1; //堆中没有数据了
		a[1] = a[count];
		--count;
		heapify(a,count,1);		
	}

	private void heapify(int[] a, int n, int i){ //自上往下堆化
		while(true){
			int maxPos = i;
			if(i*2 <= n && a[i] < a[i*2]){	
				maxPos = i*2;
			}
			if(i*2+1 <= n && a[i*2+1] > a[maxPos]){
				maxPos = i*2+1;
			}
			if(maxPos == i){
				break;
			}
			swap(a,i,maxPos);
			1 = maxPos;
		}
	}

	private void buildHeap(int a, int n){
		for(int i = n/2; i >= 1; i++){
			heapify(a,n,i) //下标是 2n​+1 到 n 的节点是叶子节点，我们不需要堆化
		}
	}

	public void sort(int[] a, int n){
		buildHeap(a,n);
		int k = n;
		while(k > 1){
			swap(a,1,k);
			--k;
			heapify(a,k,1);
		}
	}
}

第一点，堆排序数据访问的方式没有快速排序友好。对于快速排序来说，数据是顺序访问的。而对于堆排序来说，数据是跳着访问的。 比如，堆排序中，最重要的一个操作就是数据的堆化。比如下面这个例子，对堆顶节点进行堆化，会依次访问数组下标是 1，2，4，8 的元素，而不是像快速排序那样，局部顺序访问，所以，这样对 CPU 缓存是不友好的。

第二点，对于同样的数据，在排序过程中，堆排序算法的数据交换次数要多于快速排序。我们在讲排序的时候，提过两个概念，有序度和逆序度。对于基于比较的排序算法来说，整个排序过程就是由两个基本的操作组成的，比较和交换（或移动）。快速排序数据交换的次数不会比逆序度多。但是堆排序的第一步是建堆，建堆的过程会打乱数据原有的相对先后顺序，导致原数据的有序度降低。比如，对于一组已经有序的数据来说，经过建堆之后，数据反而变得更无序了。
对于第二点，你可以自己做个试验看下。我们用一个记录交换次数的变量，在代码中，每次交换的时候，我们就对这个变量加一，排序完成之后，这个变量的值就是总的数据交换次数。这样你就能很直观地理解我刚刚说的，堆排序比快速排序交换次数多。

堆中比较重要的两个操作是插入一个数据和删除堆顶元素。这两个操作都要用到堆化。插入一个数据的时候，我们把新插入的数据放到数组的最后，然后从下往上堆化；删除堆顶数据的时候，我们把数组中的最后一个元素放到堆顶，然后从上往下堆化。这两个操作时间复杂度都是 O(logn)。

除此之外，我们还讲了堆的一个经典应用，堆排序。堆排序包含两个过程，建堆和排序。我们将下标从 2n​ 到 1 的节点，依次进行从上到下的堆化操作，然后就可以将数组中的数据组织成堆这种数据结构。接下来，我们迭代地将堆顶的元素放到堆的末尾，并将堆的大小减一，然后再堆化，重复这个过程，直到堆中只剩下一个元素，整个数组中的数据就都有序排列了。