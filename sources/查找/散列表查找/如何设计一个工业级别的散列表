如何设计一个工业级别的散列表：
q:支持快速地查询、插入、删除等操作
a:设计一个合理的散列函数
q:内存占用合理，不能浪费过多的内存空间
a:定义装载因子阀值，并且设计动态扩容策略
q:性能稳定，极端情况下，散列表的性能不会退化到无法接受的情况。
a:选择合适的散列冲突解决方法

关于散列函数的设计，我们要尽量可能让散列后的值随机且均匀分布，这样会尽可能地减少散列冲突，即便冲突之后，
分配到每个槽里的数据也比较均匀。除此之外，散列函数的设计也不能太复杂，太复杂会太好耗时间，也会影响散列表的性能。

关于散列冲突解决方法的选择，大部分情况下，链表法更普适。而且，我们还可以通过将链表法中的链表改造成其他动态查找数据结构，
比如红黑树，来避免散列表时间复杂度退化成O(n),抵御散列碰撞攻击。但是，对于小规模数据、装载因子不高的散列表，比较适合开放寻址法。

LinkedHashMap是通过双向链表和散列表着俩种数据结构组合实现的。LinkedHashMap中的“Linked”实际上
指的是双向链表，并且链表法解决散列冲突。
链表中的每个节点处理储存数据(data)、前驱指针(prev)、后继指针(next)之外，还增加了一个特殊的字段hnext。
因为我们的散列表是通过链表法解决散列冲突的，所以每个结点会在俩条链中。一个链是刚刚我们提到的双向链表，
另一个链是散列表中的拉链。前驱和后继指针是为了将结点串在双向链表中，hnext指针是为了将结点串在散列表的拉链中。
LinkedHashMap不仅支持按照插入顺序遍历，还支持按照访问顺序遍历。

散列表这种数据结构虽然支持非常高效的数据插入、删除、查找操作。但是散列表中的数据都是通过散列函数打乱之后
无规律的。也就是说，它无法支持按照某种顺序快速地遍历数据。如果希望按照顺序遍历散列表中的数据，那我们需要将散列
表中的数据拷贝到数组中，然后排序再便利。
因为散列表是动态数据结构，不停地有数据的插入、删除，所以每当我们希望按顺序遍历散列表中的数据时候，都需要先
排序，那效率势必会很低。为了解决这个问题。我们将散列表和链表(或者跳表）结合在一起使用。

总结：
数组占据随机访问的优势，却需要连续内存的缺点。
链表虚有不可连续储存优势，但访问查找是线性的。
散列表和链表、跳表的混合使用，是为了结合数据和链表的优势，规避他们的不足。


