平衡二叉树的严格定义是：二叉树中任意一个节点的左右子树的高度相差不能大于1.

平衡二叉查找树中“平衡”的意思，其实就是让整颗树左右看起来比较“对称”、比较“平衡”，不要出现左子树很高、右子树很矮的情况。
这样就能让整颗树的告诉相对来说低一些，相应的插入、删除、查找操作的效率高一些。

AVL树是一种高度平衡的二叉树，所以查找效率非常高，但是，有利就有弊，AVL树为了维持这种高度平衡，就要付出更多的代价。每次插入、删除都要
做调整，就比较复杂、耗时。所以，对于有频繁的插入、删除操作的数据集合，使用AVL树的代价就有点高了。

红黑树支持做到了近似平衡，并不是严格的平衡，所以在维护平衡的成本上，要比AVL树要低。

所以，红黑树的插入、删除、查找各种操作的性能比较稳定。对于工程应用来说，要面对各种异常情况，为了支撑这种工业级的应用，
我们更倾向于使用这种性能稳定的平衡二叉查找树。

学习数据结构和算法，要学习它的由来、特性、适用的场景及它能解决的问题。对于红黑树，也不例外。你如果能搞懂这几个问题，
其实就已经足够了。

红黑树是一种平衡二叉查找树，它是为了解决普通二叉查找树在数据更新的过程中，复杂度退化的问题而产生的。红黑树的高度近似log2N，所以
它是近似平衡，插入、删除、查找的时间复杂度都是O(logn).
因为红黑树是一种性能非常稳定的二叉查找树，所以，在工程中，但凡用到动态插入、删除、查找数据的场景，都可以用到它。不过，它实现起来比较复杂，
如果自己写代码实现，难度会有些高，这个时候我们其实更倾向于用跳表替代它。

散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。

跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。

红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。散列表：插入删除查找都是O(1), 是最常用的，但其缺点是不能顺序遍历以及扩容缩容的性能损耗。适用于那些不需要顺序遍历，数据更新不那么频繁的。

跳表：插入删除查找都是O(logn), 并且能顺序遍历。缺点是空间复杂度O(n)。适用于不那么在意内存空间的，其顺序遍历和区间查找非常方便。

红黑树：插入删除查找都是O(logn), 中序遍历即是顺序遍历，稳定。缺点是难以实现，去查找不方便。其实跳表更佳，但红黑树已经用于很多地方了。

动态数据结构是支持动态的更新操作，里面存储的数据是时刻在变化的，通俗一点讲，它不仅仅支持查询，还支持删除、插入数据。而且，这些操作都非常高效。如果不高效，也就算不上是有效的动态数据结构了。所以，这里的红黑树算一个，支持动态的插入、删除、查找，而且效率都很高。链表、队列、栈实际上算不上，因为操作非常有限，查询效率不高。那现在你再想一下还有哪些支持动态插入、删除、查找数据并且效率都很高的的数据结构呢？
