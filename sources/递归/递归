递归：
电影院，想知道自己在第几排？
int f(int n){
	if(n == 1) return 1;
	return f(n-1) + 1;
}
等价于
int f(int n){
	int ret = 1;
	for(int i = 2; i < n; I++){
		ret = ret + 1;
	}
	return ret;
}
假如有n个台阶，可以每次跨1个台阶或者2个台阶
int f(int n){
	if(i == 1) return 1;
	if(i == 2) return 2;
	return f(n-1) + f(n-2);
}
等价于
int f(int n){
	if(n == 1) return 1;
	if(n == 2) return 3;
	int ret = 0;
	int pre = 2;
	int prere = 1;
	for(i = 3; i < n; I++){
	   ret = pre + prere;
           prere = pre;
	   pre = ret;			
	}
	return ret;
}
总结：
1.写递归代码的关键就是找到如何将大问题分解为小问题的规律，并且基于此写出递推公式，然后再推敲终止条件，最后将递推公式和终止条件翻译成代码。
2.编写递归代码的关键是，只要遇到递归，我们就把它抽象成一个递推公式，不用想一层层的调用关系，不要试图用人脑去分解递归的每个步骤。
3.递归有利有弊，利是递归代码的表达力很强，写起来非常简洁；而弊就是空间复杂度高、有堆栈益处分险、存在重复计算、过多的函数调用会耗时较多等问题。
4.在空间复杂度上，因为递归调用一次就会在内存栈中保存一次现场数据，所以在分析递归代码空间复杂度时，需要额外考虑这部分的开销，比如我们前面
讲到的电影院递归代码，空间复杂度并不是O(1),而是O(n).
5.递归本身就是借助栈来实现的，只不过我们使用的栈是系统或者虚拟机本身提供的，我们没有感知罢了。如果我们自己在内存堆上实现栈，手动模拟入栈出栈过程，这样任何递归代码都可以改写成看上去不是递归代码的样子。但是这种思路实际上是将递归改成“手动”递归，本质并没有变，而且也没有解决前面讲到的某些问题，徒增了实现的复杂度。

递归调试：
1.打印日志发现，递归值。
2.结合条件断点进行调试。